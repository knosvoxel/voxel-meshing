// rotates instance based on transforms
#version 460 core

struct RotationData{
    vec4 instance_size;
    vec4 rotated_size;
    vec4 min_bounds;
    mat4 transform;
};

struct VoxelData{
    uint four_voxels;
};

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0, std430) readonly buffer ssbo {
    VoxelData voxels[];
};

layout (binding = 1, std430) buffer rotated_ssbo {
    uint rotated_voxels[];
};

layout (binding = 2, std430) readonly buffer rotation_data_buffer {
    RotationData rotation_data;
};

void main() {
    vec3 voxel_pos = gl_GlobalInvocationID;
    vec3 model_size = rotation_data.instance_size.xyz;
    uint voxel_index = uint(voxel_pos.x + (voxel_pos.y * model_size.x) + (voxel_pos.z * model_size.x * model_size.y));

    VoxelData voxel_data = voxels[voxel_index / 4];
    uint shift = 8 * (voxel_index % 4);
    uint col_idx = (voxel_data.four_voxels >> shift) & 255;

    if (col_idx == 0) return;

    // rotate
    vec4 rotated_pos = floor(rotation_data.transform * vec4(voxel_pos, 1.0));

    // subtract min_bounds
    rotated_pos.xyz -= rotation_data.min_bounds.xyz;

    uint new_index = uint(rotated_pos.x + (rotated_pos.y * rotation_data.rotated_size.x) + (rotated_pos.z * rotation_data.rotated_size.x * rotation_data.rotated_size.y));

    uint target_voxel_data = new_index / 4;
    uint shift_new = 8 * (new_index % 4);

    atomicOr(rotated_voxels[target_voxel_data], (col_idx << shift_new));

}
