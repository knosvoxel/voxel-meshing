#version 460 core

struct InstanceData{
    vec4 instance_size;
    vec4 remapped_size;
    vec4 instance_position_offset;
};

struct VoxelData{
    uint four_voxels;
};

struct Vertex{
    vec3 position;
    uint packed_data; // Bytes | 0: 00000000 | 1: 00000000 | 2: normal index |3: color index |
};

struct DrawArraysIndirectCommand{
    uint count;
    uint instanceCount;
    uint first;
    uint baseInstance;
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout (binding = 0, std430) readonly buffer ssbo {
    VoxelData voxels[];
};

layout (binding = 1, std430) writeonly buffer final_vertices {
    Vertex vertices[];
};

layout (binding = 2, std430) buffer indirect_buffer {
    DrawArraysIndirectCommand indirect_command;
};

layout (binding = 3, std430) readonly buffer instance_data_buffer {
    InstanceData instance_data;
};

const vec3 normal_directions[6] = vec3[6](
    vec3(-1.0,  0.0,  0.0),  // 0
    vec3( 1.0,  0.0,  0.0),  // 1
    vec3( 0.0,  0.0, -1.0),  // 2
    vec3( 0.0,  0.0,  1.0),  // 3
    vec3( 0.0, -1.0,  0.0),  // 4
    vec3( 0.0,  1.0,  0.0)   // 5
);

// 8 uints each. One uint = one of the 8 8x8 faces in one direction
// 16 bit: processing mask: used for greedy meshing calculations (max division 2 * 2 block times 4 / 16 bit: done bits: used to save finished voxel faces

shared uint processing_buffer_x0[8];
shared uint processing_buffer_x1[8];
shared uint processing_buffer_y0[8];
shared uint processing_buffer_y1[8];
shared uint processing_buffer_z0[8];
shared uint processing_buffer_z1[8];

// lowest voxel positions for each layer in each direction
shared uint lowest_voxel_x[8];
shared uint lowest_voxel_y[8];
shared uint lowest_voxel_z[8];

void main() {
    vec3 voxel_pos = gl_GlobalInvocationID;
    vec3 local_pos = gl_LocalInvocationID.yzx;
//    uint local_index = gl_LocalInvocationIndex; // value between 0 and 511

    vec3 offset_size = instance_data.instance_size.xyz;
    vec3 model_size = instance_data.remapped_size.xyz;
    uint voxel_index = uint(voxel_pos.x + (voxel_pos.y * model_size.x) + (voxel_pos.z * model_size.x * model_size.y));

    // retrieve color index from packed voxel data (4 voxels per uint) 
    VoxelData voxel_data = voxels[voxel_index / 4];
    uint shift = 8 * (voxel_index % 4);
    uint col_idx = (voxel_data.four_voxels >> shift) & 255;

    // initialize occupied_voxels array to 0. Only set occupied voxels to 1 (early return for empty ones)
    if (gl_LocalInvocationIndex == 0){
        for (int i = 0; i < 8; ++i){
            processing_buffer_x0[i] = 0;
            processing_buffer_x1[i] = 0;
            processing_buffer_y0[i] = 0;
            processing_buffer_y1[i] = 0;
            processing_buffer_z0[i] = 0;
            processing_buffer_z1[i] = 0;

            lowest_voxel_x[i] = 0;
            lowest_voxel_y[i] = 0;
            lowest_voxel_z[i] = 0;
        }
    }

    // wait for all invocations to receive the initialized occupied_voxels array
    barrier();

//    col_idx = correct_occupy_uint + 1 + gl_WorkGroupID.x % 2;
//
    uint correct_y_mask = uint(local_pos.y); // value between 0 and 7
    uint correct_y_mask_bit = uint(8 * local_pos.x + local_pos.z); // value between 0 and 63         2nd half of bits is used to process data

    // voxel empty = pass
//    if(col_idx == 0) {
//        atomicOr(processing_buffer_y0[correct_y_mask], 1 << (16 + correct_processing_bit)
//        return
//    };

    // workgroup visualization debug
    //    col_idx = (gl_WorkGroupID.x 
    //                + gl_WorkGroupID.y * 3
    //                + gl_WorkGroupID.z * 5) % 255 + 1;

    // vox format coordinates to OpenGL coordinates
    vec3 voxel_pos_flipped = vec3(voxel_pos.y, voxel_pos.z, voxel_pos.x);
    vec3 voxel_pos_translated = voxel_pos_flipped + instance_data.instance_position_offset.yzx - vec3(floor(offset_size.y / 2.0), floor(offset_size.z / 2.0), floor(offset_size.x / 2.0));

    // neighouring voxel color indices
    uint col_idx_x0 = 0;
    uint col_idx_x1 = 0;
    uint col_idx_y0 = 0;
    uint col_idx_y1 = 0;
    uint col_idx_z0 = 0;
    uint col_idx_z1 = 0;

    //correct order: (y, z, x) : x -> y / y -> z / z -> x (left: OpenGL, right: MV)
    vec3 neigh_x0 = vec3(voxel_pos.x, voxel_pos.y - 1.0, voxel_pos.z);
    bool x0_in_area = !(neigh_x0.y < 0.0);
    if (x0_in_area){
        uint x0_index = uint((neigh_x0.z * model_size.y * model_size.x) + (neigh_x0.y * model_size.x) + neigh_x0.x);
        VoxelData neigh_x0_data = voxels[x0_index / 4];
        uint neigh_shift = (8 * (x0_index % 4));
        col_idx_x0 = (neigh_x0_data.four_voxels >> neigh_shift) & 255;
    }

    //correct order: (y, z, x) : x -> y / y -> z / z -> x 
    vec3 neigh_x1 = vec3(voxel_pos.x, voxel_pos.y + 1.0, voxel_pos.z);
    bool x1_in_area = !(neigh_x1.y >= model_size.y);
    if (x1_in_area) {
        uint x1_index = uint((neigh_x1.z * model_size.y * model_size.x) + (neigh_x1.y * model_size.x) + neigh_x1.x);
        VoxelData neigh_x1_data = voxels[x1_index / 4];
        uint neigh_shift = (8 * (x1_index % 4));
        col_idx_x1 = (neigh_x1_data.four_voxels >> neigh_shift) & 255;
    }

    //correct order: (y, z, x) : x -> y / y -> z / z -> x 
    vec3 neigh_z0 = vec3(voxel_pos.x - 1.0, voxel_pos.y, voxel_pos.z);
    bool z0_in_area = !(neigh_z0.x < 0.0);
    if (z0_in_area) {
        uint z0_index = uint((neigh_z0.z * model_size.y * model_size.x) + (neigh_z0.y * model_size.x) + neigh_z0.x);
        VoxelData neigh_z0_data = voxels[z0_index / 4];
        uint neigh_shift = (8 * (z0_index % 4));
        col_idx_z0 = (neigh_z0_data.four_voxels >> neigh_shift) & 255;
    }

    //correct order: (y, z, x) : x -> y / y -> z / z -> x 
    vec3 neigh_z1 = vec3(voxel_pos.x + 1.0, voxel_pos.y, voxel_pos.z);
    bool z1_in_area = !(neigh_z1.x >= model_size.x);
    if (z1_in_area) {
        uint z1_index = uint((neigh_z1.z * model_size.y * model_size.x) + (neigh_z1.y * model_size.x) + neigh_z1.x);
        VoxelData neigh_z1_data = voxels[z1_index / 4];
        uint neigh_shift = (8 * (z1_index % 4));
        col_idx_z1 = (neigh_z1_data.four_voxels >> neigh_shift) & 255;
    }

    //correct order: (y, z, x) : x -> y / y -> z / z -> x 
    vec3 neigh_y0 = vec3(voxel_pos.x, voxel_pos.y, voxel_pos.z - 1.0);
    bool y0_in_area = !(neigh_y0.z < 0.0);
    if (y0_in_area) {
        uint y0_index = uint((neigh_y0.z * model_size.y * model_size.x) + (neigh_y0.y * model_size.x) + neigh_y0.x);
        VoxelData neigh_y0_data = voxels[y0_index / 4];
        uint neigh_shift = (8 * (y0_index % 4));
        col_idx_y0 = (neigh_y0_data.four_voxels >> neigh_shift) & 255;
    }

    //correct order: (y, z, x) : x -> y / y -> z / z -> x 
    vec3 neigh_y1 = vec3(voxel_pos.x, voxel_pos.y, voxel_pos.z + 1.0);
    bool y1_in_area = !(neigh_y1.z >= model_size.z);
    if (y1_in_area) {
        uint y1_index = uint((neigh_y1.z * model_size.y * model_size.x) + (neigh_y1.y * model_size.x) + neigh_y1.x);
        VoxelData neigh_y1_data = voxels[y1_index / 4];
        uint neigh_shift = (8 * (y1_index % 4));
        col_idx_y1 = (neigh_y1_data.four_voxels >> neigh_shift) & 255;
    }

    //uint local_x_index = TODO;

    //uint local_z_index = TODO;


    // 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0
    // ... | 32768 16384 8192 4096 2048 1024 512 256 | 128 64 32 16 8 4 2 1
    // step down in face size
    // i: used to calculate correct bit positions
    for (int i = 1; i > 0; i /= 2){ // 1 | 4 | 16 work blocks

//      ...............
        //x
        /////////////////////////////
        // 56 57 58 59 60 61 62 63 //
        // 48 49 50 51 52 53 54 55 //
        // 40 41 42 43 44 45 46 47 //
        // 32 33 34 35 36 37 38 39 //
        // 24 25 26 27 28 29 30 31 //
        // 16 17 18 19 20 21 22 23 //
        // 8  9  10 11 12 13 14 15 //
        // 0  1  2  3  4  5  6  7  // layer 3
        /////////////////////////////z

        /////////////////
        // 12 13 14 15 //
        // 8  9  10 11 //
        // 4  5  6  7  //
        // 0  1  2  3  // layer 2
        /////////////////

        /////////
        // 2 3 //
        // 0 1 // layer 1
        /////////

        ///////
        // 0 // layer 0
        ///////

        //   face y0  //

        // check if 2x2 group of voxels has been processed yet
        if (!bool((processing_buffer_y0[correct_y_mask] >> (correct_y_mask_bit / 4)) & 1)){     // 0 = face not processed yet
            
            // if not layer 3
            if (i > 1){
                // example 17: 
                // layer 0: i = 3 | (8 / 8) * (2 / 8) + 1 / 8 = 1 * 0 + 0 = 0
                // layer 1: i = 2 | (8 / 4) * (2 / 4) + 1 / 4 = 2 * 0 + 0 = 0
                // layer 2: i = 1 | (8 / 2) * (2 / 2) + 1 / 2 = 4 * 1 + 0 = 4
                // layer 3: i = 0 | (8 / 1) * (2 / 1) + 1 / 1 = 8 * 2 + 1 = 17

                if (gl_LocalInvocationIndex == 0){
                    for (int i = 0; i < 8; ++i){
                        atomicAnd(processing_buffer_y0[i], 0x0000FFFF);
                    }
                }

                if (int(local_pos.x) % i == 0 && int(local_pos.z) % i == 0){
                    atomicMin(lowest_voxel_y[int(local_pos.y)], gl_LocalInvocationIndex); // TODO: This index is mapped to the wrong coordinate sytem, fix it!
                }

                barrier();
                // processing bits from left to right (uint layout): | 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 | done data |
                // up to layer 2, single faces are handled differently
                int correct_processing_bit = (8 / i) * int(local_pos.x / i) + int(local_pos.z) / i;
                // check whether face can potentially be processed into bigger face based on neighbouring color indices

                int processing_bit_x0 = -1;
                int processing_bit_x1 = -1;
                int processing_bit_z0 = -1;
                int processing_bit_z1 = -1;

//                if(x0_in_area)
                processing_bit_x0 = (8 / i) * int((local_pos.x - 1.0) / i) + int(local_pos.z) / i;
//                if(x1_in_area)
                processing_bit_x1 = (8 / i) * int((local_pos.x + 1.0) / i) + int(local_pos.z) / i;
//                if(z0_in_area)
                processing_bit_z0 = (8 / i) * int((local_pos.x) / i) + int(local_pos.z - 1.0) / i;
//                if(z1_in_area)
                processing_bit_z1 = (8 / i) * int((local_pos.x) / i) + int(local_pos.z + 1.0) / i;

                if (
                    (correct_processing_bit == processing_bit_x0 && col_idx_x0 != col_idx) ||
                    (correct_processing_bit == processing_bit_x1 && col_idx_x1 != col_idx) ||
                    (correct_processing_bit == processing_bit_z0 && col_idx_z0 != col_idx) ||
                    (correct_processing_bit == processing_bit_z1 && col_idx_z1 != col_idx) ||
                    (col_idx_y0 != 0) ||
                    (col_idx == 0)
                )
                {
                    atomicOr(processing_buffer_y0[correct_y_mask], 1 << (16 + correct_processing_bit));
                }

                // wait for all faces to write their bits into the processing mask
                barrier();

                // always 1?
                uint processing_bit_state = (processing_buffer_y0[correct_y_mask] >> (16 + correct_processing_bit)) & 1;
                //processing_bit_state = 0;
                // 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0

                // if processing mask bit is still 0 this face can be created!
                if ((processing_bit_state & 1) == 0)
                {
                    if (gl_LocalInvocationIndex == lowest_voxel_y[int(local_pos.y)]){
                        uint local_base_idx = atomicAdd(indirect_command.count, 6);
                                        
                        uint normal_index = 5; // todo: change back to 4
                        uint x4_packed_data = (col_idx & 255) | (normal_index << 8);

                        Vertex v0, v1, v2, v3, v4, v5;
                        v0.position = voxel_pos_translated;
                        v0.packed_data = x4_packed_data;
                        v1.position = voxel_pos_translated + vec3(1.0, 0.0, 1.0) * i;
                        v1.packed_data = x4_packed_data;
                        v2.position = voxel_pos_translated + vec3(1.0, 0.0, 0.0) * i;
                        v2.packed_data = x4_packed_data;

                        v3.position = voxel_pos_translated + vec3(1.0, 0.0, 1.0) * i;
                        v3.packed_data = x4_packed_data;
                        v4.position = voxel_pos_translated;
                        v4.packed_data = x4_packed_data;    
                        v5.position = voxel_pos_translated + vec3(0.0, 0.0, 1.0) * i;
                        v5.packed_data = x4_packed_data;

                        vertices[local_base_idx] = v0;
                        vertices[local_base_idx + 1] = v1;
                        vertices[local_base_idx + 2] = v2;
                        vertices[local_base_idx + 3] = v3;
                        vertices[local_base_idx + 4] = v4;
                        vertices[local_base_idx + 5] = v5;
                        
                        continue;
                    }

                    atomicOr(processing_buffer_y0[correct_y_mask], 1 << (correct_y_mask_bit / 4));

                }

                barrier();

            }

            else{
                if (col_idx_y0 != 0 || col_idx == 0)
                    continue;

                col_idx = correct_y_mask + 1;
                // single face at position

                uint local_base_idx = atomicAdd(indirect_command.count, 6);

                uint normal_index = 5; // todo: change back to 4
                uint x4_packed_data = (col_idx & 255) | (normal_index << 8);

                Vertex v0, v1, v2, v3, v4, v5;
                v0.position = voxel_pos_translated + vec3(0.0, 0.0, 0.0);
                v0.packed_data = x4_packed_data;
                v1.position = voxel_pos_translated + vec3(1.0, 0.0, 1.0);
                v1.packed_data = x4_packed_data;
                v2.position = voxel_pos_translated + vec3(1.0, 0.0, 0.0);
                v2.packed_data = x4_packed_data;

                v3.position = voxel_pos_translated + vec3(1.0, 0.0, 1.0);
                v3.packed_data = x4_packed_data;
                v4.position = voxel_pos_translated + vec3(0.0, 0.0, 0.0);
                v4.packed_data = x4_packed_data;
                v5.position = voxel_pos_translated + vec3(0.0, 0.0, 1.0);
                v5.packed_data = x4_packed_data;

                vertices[local_base_idx] = v0;
                vertices[local_base_idx + 1] = v1;
                vertices[local_base_idx + 2] = v2;
                vertices[local_base_idx + 3] = v3;
                vertices[local_base_idx + 4] = v4;
                vertices[local_base_idx + 5] = v5;
            }

            barrier();

        }


        barrier();

        // face y0 end //
    }
}