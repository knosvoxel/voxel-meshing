#version 460 core

struct InstanceData{
    vec4 instance_size;
    vec4 remapped_size;
    vec4 instance_position_offset;
};

struct VoxelData{
    uint four_voxels;
};

struct Vertex{
    vec3 position;
    uint packed_data; // Bytes | 0: 00000000 | 1: 00000000 | 2: normal index |3: color index |
};

struct DrawArraysIndirectCommand{
    uint count;
    uint instanceCount;
    uint first;
    uint baseInstance;
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout (binding = 0, std430) readonly buffer ssbo {
    VoxelData voxels[];
};

layout (binding = 1, std430) writeonly buffer final_vertices {
    Vertex vertices[];
};

layout (binding = 2, std430) buffer indirect_buffer {
    DrawArraysIndirectCommand indirect_command;
};

layout (binding = 3, std430) readonly buffer instance_data_buffer {
    InstanceData instance_data;
};

const vec3 normal_directions[6] = vec3[6](
    vec3(-1.0,  0.0,  0.0),  // 0
    vec3( 1.0,  0.0,  0.0),  // 1
    vec3( 0.0,  0.0, -1.0),  // 2
    vec3( 0.0,  0.0,  1.0),  // 3
    vec3( 0.0, -1.0,  0.0),  // 4
    vec3( 0.0,  1.0,  0.0)   // 5
);

// 8 uints each. One uint = one of the 8 8x8 faces in one direction
// 16 bit: processing mask: used for greedy meshing calculations (max division 2 * 2 block times 4 / 16 bit: done bits: used to save finished voxel faces

shared uint processing_buffer_x0[8];
shared uint processing_buffer_x1[8];
shared uint processing_buffer_y0[8];
shared uint processing_buffer_y1[8];
shared uint processing_buffer_z0[8];
shared uint processing_buffer_z1[8];

bool pos_in_bounds(vec3 pos, vec3 model_size){
    if (pos.x < 0 || pos.y < 0 || pos.z < 0 ||
        pos.x >= int(model_size.x) || pos.y >= int(model_size.y) || pos.z >= int(model_size.z)) {
        return false;
    }
    else{
        return true;
    }
}

uint get_col_idx(vec3 pos, vec3 model_size){
    uint index = uint(pos.x + pos.y * uint(model_size.x) + pos.z * uint(model_size.x * model_size.y));
    VoxelData data = voxels[index / 4];
    return (data.four_voxels >> (8 * (index % 4))) & 255;
}

void main() {
    vec3 voxel_pos = gl_GlobalInvocationID;
    vec3 local_pos = gl_LocalInvocationID.yzx;

    vec3 offset_size = instance_data.instance_size.xyz;
    vec3 model_size = instance_data.remapped_size.xyz;
    uint voxel_index = uint(voxel_pos.x + (voxel_pos.y * model_size.x) + (voxel_pos.z * model_size.x * model_size.y));

    // retrieve color index from packed voxel data (4 voxels per uint) 
    VoxelData voxel_data = voxels[voxel_index / 4];
    uint shift = 8 * (voxel_index % 4);
    uint col_idx = (voxel_data.four_voxels >> shift) & 255;

    // initialize occupied_voxels array to 0. Only set occupied voxels to 1 (early return for empty ones)
    if (gl_LocalInvocationIndex == 0){
        for (int i = 0; i < 8; i++){
            processing_buffer_x0[i] = 0;
            processing_buffer_x1[i] = 0;
            processing_buffer_y0[i] = 0;
            processing_buffer_y1[i] = 0;
            processing_buffer_z0[i] = 0;
            processing_buffer_z1[i] = 0;
        }
    }

    // wait for all invocations to receive the initialized occupied_voxels array
    barrier();

    // workgroup visualization debug
    //    col_idx = (gl_WorkGroupID.x 
    //                + gl_WorkGroupID.y * 3
    //                + gl_WorkGroupID.z * 5) % 255 + 1;

    // vox format coordinates to OpenGL coordinates
    vec3 voxel_pos_flipped = vec3(voxel_pos.y, voxel_pos.z, voxel_pos.x);
    vec3 voxel_pos_translated = voxel_pos_flipped + instance_data.instance_position_offset.yzx - vec3(floor(offset_size.y / 2.0), floor(offset_size.z / 2.0), floor(offset_size.x / 2.0));

    // neighouring voxel color indices
    uint col_idx_x0 = 0;
    uint col_idx_x1 = 0;
    uint col_idx_y0 = 0;
    uint col_idx_y1 = 0;
    uint col_idx_z0 = 0;
    uint col_idx_z1 = 0;

    //correct order: (y, z, x) : x -> y / y -> z / z -> x (left: OpenGL, right: MV)
    vec3 neigh_x0 = vec3(voxel_pos.x, voxel_pos.y - 1.0, voxel_pos.z);
    bool x0_in_bounds = pos_in_bounds(neigh_x0, model_size);
    if (x0_in_bounds) col_idx_x0 = get_col_idx(neigh_x0, model_size);

    //correct order: (y, z, x) : x -> y / y -> z / z -> x 
    vec3 neigh_x1 = vec3(voxel_pos.x, voxel_pos.y + 1.0, voxel_pos.z);
    bool x1_in_bounds = pos_in_bounds(neigh_x1, model_size);
    if (x1_in_bounds) col_idx_x1 = get_col_idx(neigh_x1, model_size);

    //correct order: (y, z, x) : x -> y / y -> z / z -> x 
    vec3 neigh_z0 = vec3(voxel_pos.x - 1.0, voxel_pos.y, voxel_pos.z);
    bool z0_in_bounds = pos_in_bounds(neigh_z0, model_size);
    if (z0_in_bounds) col_idx_z0 = get_col_idx(neigh_z0, model_size);

    //correct order: (y, z, x) : x -> y / y -> z / z -> x 
    vec3 neigh_z1 = vec3(voxel_pos.x + 1.0, voxel_pos.y, voxel_pos.z);
    bool z1_in_bounds = pos_in_bounds(neigh_z1, model_size);
    if (z1_in_bounds) col_idx_z1 = get_col_idx(neigh_z1, model_size);

    //correct order: (y, z, x) : x -> y / y -> z / z -> x 
    vec3 neigh_y0 = vec3(voxel_pos.x, voxel_pos.y, voxel_pos.z - 1.0);
    bool y0_in_bounds = pos_in_bounds(neigh_y0, model_size);
    if (y0_in_bounds) col_idx_y0 = get_col_idx(neigh_y0, model_size);

    //correct order: (y, z, x) : x -> y / y -> z / z -> x 
    vec3 neigh_y1 = vec3(voxel_pos.x, voxel_pos.y, voxel_pos.z + 1.0);
    bool y1_in_bounds = pos_in_bounds(neigh_y1, model_size);
    if (y1_in_bounds) col_idx_y1 = get_col_idx(neigh_y1, model_size);


    uint correct_x_mask = uint(local_pos.x); // value between 0 and 7
    uint x_mask_done_bit = uint(4 * (uint(local_pos.z) / 2) + uint(local_pos.y) / 2); // value between 0 and 15         2nd half of bits is used to process data
   
    uint correct_z_mask = uint(local_pos.z); // value between 0 and 7
    uint z_mask_done_bit = uint(4 * (uint(local_pos.x) / 2) + uint(local_pos.y) / 2); // value between 0 and 15         2nd half of bits is used to process data

    uint correct_y_mask = uint(local_pos.y); // value between 0 and 7
    uint y_mask_done_bit = uint(4 * (uint(local_pos.x) / 2) + uint(local_pos.z) / 2); // value between 0 and 15         2nd half of bits is used to process data

    bool x0_in_area, x1_in_area, y0_in_area, y1_in_area, z0_in_area, z1_in_area;

    // step down in face size // 8 * 8 | 4 * 4 | 2 * 2 | 1 * 1
    // i: used to calculate correct bit positions
    for (int i = 8; i > 0; i /= 2){

    
        ///////
        // 0 // layer 0
        ///////

        /////////
        // 2 3 //
        // 0 1 // layer 1
        /////////

        /////////////////
        // 12 13 14 15 //
        // 8  9  10 11 //
        // 4  5  6  7  //
        // 0  1  2  3  // layer 2
        /////////////////

        //x
        /////////////////////////////
        // 56 57 58 59 60 61 62 63 //
        // 48 49 50 51 52 53 54 55 //
        // 40 41 42 43 44 45 46 47 //
        // 32 33 34 35 36 37 38 39 //
        // 24 25 26 27 28 29 30 31 //
        // 16 17 18 19 20 21 22 23 //
        // 8  9  10 11 12 13 14 15 //
        // 0  1  2  3  4  5  6  7  // layer 3
        /////////////////////////////z

        if (gl_LocalInvocationIndex == 0){
            for (int i = 0; i < 8; i++){
                atomicAnd(processing_buffer_x0[i], 0x0000FFFF);
                atomicAnd(processing_buffer_x1[i], 0x0000FFFF);
                atomicAnd(processing_buffer_z0[i], 0x0000FFFF);
                atomicAnd(processing_buffer_z1[i], 0x0000FFFF);
                atomicAnd(processing_buffer_y0[i], 0x0000FFFF);
                atomicAnd(processing_buffer_y1[i], 0x0000FFFF);
            }
        }

        barrier();

        // update in_area bools for current possible face size
        int(local_pos.x) % i != 0 ? x0_in_area = true : x0_in_area = false;
        int(local_pos.x + 1) % i != 0 ? x1_in_area = true : x1_in_area = false;
        int(local_pos.y) % i != 0 ? y0_in_area = true : y0_in_area = false;
        int(local_pos.y + 1) % i != 0 ? y1_in_area = true : y1_in_area = false;
        int(local_pos.z) % i != 0 ? z0_in_area = true : z0_in_area = false;
        int(local_pos.z + 1) % i != 0 ? z1_in_area = true : z1_in_area = false;

        //   face x0  //

        // check if 2x2 group of voxels has been processed yet
        if (!bool((processing_buffer_x0[correct_x_mask] >> (x_mask_done_bit)) & 1)){     // 0 = face not processed yet

            // if not layer 3
            // up to layer 2, single faces are handled differently
            if (i > 1){
                // example 17: 
                // layer 0: i = 3 | (8 / 8) * (2 / 8) + 1 / 8 = 1 * 0 + 0 = 0
                // layer 1: i = 2 | (8 / 4) * (2 / 4) + 1 / 4 = 2 * 0 + 0 = 0
                // layer 2: i = 1 | (8 / 2) * (2 / 2) + 1 / 2 = 4 * 1 + 0 = 4
                // layer 3: i = 0 | (8 / 1) * (2 / 1) + 1 / 1 = 8 * 2 + 1 = 17

                // processing bits from left to right (uint layout): | 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 | done data |

                int correct_processing_bit = (8 / i) * (int(local_pos.y) / i) + (int(local_pos.z) / i);
                
                // check whether face can potentially be processed into bigger face based on neighbouring color indices

                int processing_bit_z0 = -1;
                int processing_bit_z1 = -1;
                int processing_bit_y0 = -1;
                int processing_bit_y1 = -1;

                if(z0_in_area)
                    processing_bit_z0 = (8 / i) * (int(local_pos.y) / i) + (int(local_pos.z - 1.0) / i);
                if(z1_in_area)
                    processing_bit_z1 = (8 / i) * (int(local_pos.y) / i) + (int(local_pos.z + 1.0) / i);
                if(y0_in_area)
                    processing_bit_y0 = (8 / i) * (int(local_pos.y - 1.0) / i) + (int(local_pos.z) / i);
                if(y1_in_area)
                    processing_bit_y1 = (8 / i) * (int(local_pos.y + 1.0) / i) + (int(local_pos.z) / i);


                if (
                    (correct_processing_bit == processing_bit_z0 && col_idx_z0 != col_idx) ||
                    (correct_processing_bit == processing_bit_z1 && col_idx_z1 != col_idx) ||
                    (correct_processing_bit == processing_bit_y0 && col_idx_y0 != col_idx) ||
                    (correct_processing_bit == processing_bit_y1 && col_idx_y1 != col_idx) ||
                    (col_idx_x0 != 0) ||
                    (col_idx == 0)
                )
                {
                    atomicOr(processing_buffer_x0[correct_x_mask], 1 << (16 + correct_processing_bit));
                }

                // wait for all faces to write their bits into the processing mask
                barrier();

                uint processing_bit_state = (processing_buffer_x0[correct_x_mask] >> (16 + correct_processing_bit)) & 1;
                // 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0

                // if processing mask bit is still 0 this face can be created!
                if ((processing_bit_state & 1) == 0)
                {
                    if (int(local_pos.z) % i == 0 && int(local_pos.y) % i == 0){
                        uint local_base_idx = atomicAdd(indirect_command.count, 6);
                        
                        uint normal_index = 0;
                        uint x0_packed_data = (col_idx & 255) | (normal_index << 8);

                        Vertex v0, v1, v2, v3, v4, v5;
                        v0.position = voxel_pos_translated + vec3(0.0, 1.0, 1.0) * i;
                        v0.packed_data = x0_packed_data;
                        v1.position = voxel_pos_translated;
                        v1.packed_data = x0_packed_data;
                        v2.position = voxel_pos_translated + vec3(0.0, 1.0, 0.0) * i;
                        v2.packed_data = x0_packed_data;

                        v3.position = voxel_pos_translated;
                        v3.packed_data = x0_packed_data;
                        v4.position = voxel_pos_translated + vec3(0.0, 1.0, 1.0) * i;
                        v4.packed_data = x0_packed_data;    
                        v5.position = voxel_pos_translated + vec3(0.0, 0.0, 1.0) * i;
                        v5.packed_data = x0_packed_data;

                        vertices[local_base_idx] = v0;
                        vertices[local_base_idx + 1] = v1;
                        vertices[local_base_idx + 2] = v2;
                        vertices[local_base_idx + 3] = v3;
                        vertices[local_base_idx + 4] = v4;
                        vertices[local_base_idx + 5] = v5;
                    }

                    atomicOr(processing_buffer_x0[correct_x_mask], 1 << (x_mask_done_bit));

                }

            }

            else{
                // single face at position
                if (col_idx_x0 == 0 && col_idx != 0){
                    uint local_base_idx = atomicAdd(indirect_command.count, 6);

                    uint normal_index = 0;
                    uint x0_packed_data = (col_idx & 255) | (normal_index << 8);

                    Vertex v0, v1, v2, v3, v4, v5;
                    v0.position = voxel_pos_translated + vec3(0.0, 1.0, 1.0);
                    v0.packed_data = x0_packed_data;
                    v1.position = voxel_pos_translated;
                    v1.packed_data = x0_packed_data;
                    v2.position = voxel_pos_translated + vec3(0.0, 1.0, 0.0);
                    v2.packed_data = x0_packed_data;

                    v3.position = voxel_pos_translated;
                    v3.packed_data = x0_packed_data;
                    v4.position = voxel_pos_translated + vec3(0.0, 1.0, 1.0);
                    v4.packed_data = x0_packed_data;    
                    v5.position = voxel_pos_translated + vec3(0.0, 0.0, 1.0);
                    v5.packed_data = x0_packed_data;

                    vertices[local_base_idx] = v0;
                    vertices[local_base_idx + 1] = v1;
                    vertices[local_base_idx + 2] = v2;
                    vertices[local_base_idx + 3] = v3;
                    vertices[local_base_idx + 4] = v4;
                    vertices[local_base_idx + 5] = v5;
                }
            }
        }

        barrier();

        // face x0 end //

        //   face x1  //

        // check if 2x2 group of voxels has been processed yet
        if (!bool((processing_buffer_x1[correct_x_mask] >> (x_mask_done_bit)) & 1)){     // 0 = face not processed yet

            // if not layer 3
            // up to layer 2, single faces are handled differently
            if (i > 1){
                // example 17: 
                // layer 0: i = 3 | (8 / 8) * (2 / 8) + 1 / 8 = 1 * 0 + 0 = 0
                // layer 1: i = 2 | (8 / 4) * (2 / 4) + 1 / 4 = 2 * 0 + 0 = 0
                // layer 2: i = 1 | (8 / 2) * (2 / 2) + 1 / 2 = 4 * 1 + 0 = 4
                // layer 3: i = 0 | (8 / 1) * (2 / 1) + 1 / 1 = 8 * 2 + 1 = 17

                // processing bits from left to right (uint layout): | 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 | done data |

                int correct_processing_bit = (8 / i) * (int(local_pos.y) / i) + (int(local_pos.z) / i);
                
                // check whether face can potentially be processed into bigger face based on neighbouring color indices

                int processing_bit_z0 = -1;
                int processing_bit_z1 = -1;
                int processing_bit_y0 = -1;
                int processing_bit_y1 = -1;

                if(z0_in_area)
                    processing_bit_z0 = (8 / i) * (int(local_pos.y) / i) + (int(local_pos.z - 1.0) / i);
                if(z1_in_area)
                    processing_bit_z1 = (8 / i) * (int(local_pos.y) / i) + (int(local_pos.z + 1.0) / i);
                if(y0_in_area)
                    processing_bit_y0 = (8 / i) * (int(local_pos.y - 1.0) / i) + (int(local_pos.z) / i);
                if(y1_in_area)
                    processing_bit_y1 = (8 / i) * (int(local_pos.y + 1.0) / i) + (int(local_pos.z) / i);


                if (
                    (correct_processing_bit == processing_bit_z0 && col_idx_z0 != col_idx) ||
                    (correct_processing_bit == processing_bit_z1 && col_idx_z1 != col_idx) ||
                    (correct_processing_bit == processing_bit_y0 && col_idx_y0 != col_idx) ||
                    (correct_processing_bit == processing_bit_y1 && col_idx_y1 != col_idx) ||
                    (col_idx_x1 != 0) ||
                    (col_idx == 0)
                )
                {
                    atomicOr(processing_buffer_x1[correct_x_mask], 1 << (16 + correct_processing_bit));
                }

                // wait for all faces to write their bits into the processing mask
                barrier();

                uint processing_bit_state = (processing_buffer_x1[correct_x_mask] >> (16 + correct_processing_bit)) & 1;
                // 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0

                // if processing mask bit is still 0 this face can be created!
                if ((processing_bit_state & 1) == 0)
                {
                    if (int(local_pos.z) % i == 0 && int(local_pos.y) % i == 0){
                        uint local_base_idx = atomicAdd(indirect_command.count, 6);

                        uint normal_index = 1;
                        uint x1_packed_data = (col_idx & 255) | (normal_index << 8);

                        Vertex v0, v1, v2, v3, v4, v5;
                        v0.position = voxel_pos_translated + vec3(0.0, 1.0, 1.0) * i + vec3(1.0, 0.0, 0.0);
                        v0.packed_data = x1_packed_data;
                        v1.position = voxel_pos_translated + vec3(0.0, 1.0, 0.0) * i + vec3(1.0, 0.0, 0.0);
                        v1.packed_data = x1_packed_data;
                        v2.position = voxel_pos_translated + vec3(1.0, 0.0, 0.0);
                        v2.packed_data = x1_packed_data;

                        v3.position = voxel_pos_translated + vec3(1.0, 0.0, 0.0);
                        v3.packed_data = x1_packed_data;
                        v4.position = voxel_pos_translated + vec3(0.0, 0.0, 1.0) * i + vec3(1.0, 0.0, 0.0);
                        v4.packed_data = x1_packed_data;    
                        v5.position = voxel_pos_translated + vec3(0.0, 1.0, 1.0) * i + vec3(1.0, 0.0, 0.0);
                        v5.packed_data = x1_packed_data;

                        vertices[local_base_idx] = v0;
                        vertices[local_base_idx + 1] = v1;
                        vertices[local_base_idx + 2] = v2;
                        vertices[local_base_idx + 3] = v3;
                        vertices[local_base_idx + 4] = v4;
                        vertices[local_base_idx + 5] = v5;
                    }

                    atomicOr(processing_buffer_x1[correct_x_mask], 1 << (x_mask_done_bit));

                }

            }

            else{
                // single face at position
                if (col_idx_x1 == 0 && col_idx != 0){
                    uint local_base_idx = atomicAdd(indirect_command.count, 6);

                    uint normal_index = 1;
                    uint x1_packed_data = (col_idx & 255) | (normal_index << 8);

                    Vertex v0, v1, v2, v3, v4, v5;
                    v0.position = voxel_pos_translated + vec3(1.0, 1.0, 1.0);
                    v0.packed_data = x1_packed_data;
                    v1.position = voxel_pos_translated + vec3(1.0, 1.0, 0.0);
                    v1.packed_data = x1_packed_data;
                    v2.position = voxel_pos_translated + vec3(1.0, 0.0, 0.0);
                    v2.packed_data = x1_packed_data;

                    v3.position = voxel_pos_translated + vec3(1.0, 0.0, 0.0);
                    v3.packed_data = x1_packed_data;
                    v4.position = voxel_pos_translated + vec3(1.0, 0.0, 1.0);
                    v4.packed_data = x1_packed_data;    
                    v5.position = voxel_pos_translated + vec3(1.0, 1.0, 1.0);
                    v5.packed_data = x1_packed_data;

                    vertices[local_base_idx] = v0;
                    vertices[local_base_idx + 1] = v1;
                    vertices[local_base_idx + 2] = v2;
                    vertices[local_base_idx + 3] = v3;
                    vertices[local_base_idx + 4] = v4;
                    vertices[local_base_idx + 5] = v5;
                }
            }
        }

        barrier();

        // face x1 end //

        //   face z0  //

        // check if 2x2 group of voxels has been processed yet
        if (!bool((processing_buffer_z0[correct_z_mask] >> (z_mask_done_bit)) & 1)){     // 0 = face not processed yet

            // if not layer 3
            // up to layer 2, single faces are handled differently
            if (i > 1){
                // example 17: 
                // layer 0: i = 3 | (8 / 8) * (2 / 8) + 1 / 8 = 1 * 0 + 0 = 0
                // layer 1: i = 2 | (8 / 4) * (2 / 4) + 1 / 4 = 2 * 0 + 0 = 0
                // layer 2: i = 1 | (8 / 2) * (2 / 2) + 1 / 2 = 4 * 1 + 0 = 4
                // layer 3: i = 0 | (8 / 1) * (2 / 1) + 1 / 1 = 8 * 2 + 1 = 17

                // processing bits from left to right (uint layout): | 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 | done data |

                int correct_processing_bit = (8 / i) * (int(local_pos.y) / i) + (int(local_pos.x) / i);
                
                // check whether face can potentially be processed into bigger face based on neighbouring color indices

                int processing_bit_x0 = -1;
                int processing_bit_x1 = -1;
                int processing_bit_y0 = -1;
                int processing_bit_y1 = -1;

                if(x0_in_area)
                    processing_bit_x0 = (8 / i) * (int(local_pos.y) / i) + (int(local_pos.x - 1.0) / i);
                if(x1_in_area)
                    processing_bit_x1 = (8 / i) * (int(local_pos.y) / i) + (int(local_pos.x + 1.0) / i);
                if(y0_in_area)
                    processing_bit_y0 = (8 / i) * (int(local_pos.y - 1.0) / i) + (int(local_pos.x) / i);
                if(y1_in_area)
                    processing_bit_y1 = (8 / i) * (int(local_pos.y + 1.0) / i) + (int(local_pos.x) / i);


                if (
                    (correct_processing_bit == processing_bit_x0 && col_idx_x0 != col_idx) ||
                    (correct_processing_bit == processing_bit_x1 && col_idx_x1 != col_idx) ||
                    (correct_processing_bit == processing_bit_y0 && col_idx_y0 != col_idx) ||
                    (correct_processing_bit == processing_bit_y1 && col_idx_y1 != col_idx) ||
                    (col_idx_z0 != 0) ||
                    (col_idx == 0)
                )
                {
                    atomicOr(processing_buffer_z0[correct_z_mask], 1 << (16 + correct_processing_bit));
                }

                // wait for all faces to write their bits into the processing mask
                barrier();

                uint processing_bit_state = (processing_buffer_z0[correct_z_mask] >> (16 + correct_processing_bit)) & 1;
                // 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0

                // if processing mask bit is still 0 this face can be created!
                if ((processing_bit_state & 1) == 0)
                {
                    if (int(local_pos.x) % i == 0 && int(local_pos.y) % i == 0){
                        uint local_base_idx = atomicAdd(indirect_command.count, 6);
                        
                        uint normal_index = 2;
                        uint z0_packed_data = (col_idx & 255) | (normal_index << 8);

                        Vertex v0, v1, v2, v3, v4, v5;
                        v0.position = voxel_pos_translated;
                        v0.packed_data = z0_packed_data;
                        v1.position = voxel_pos_translated + vec3(1.0, 0.0, 0.0) * i;
                        v1.packed_data = z0_packed_data;
                        v2.position = voxel_pos_translated + vec3(1.0, 1.0, 0.0) * i;
                        v2.packed_data = z0_packed_data;

                        v3.position = voxel_pos_translated;
                        v3.packed_data = z0_packed_data;
                        v4.position = voxel_pos_translated + vec3(1.0, 1.0, 0.0) * i;
                        v4.packed_data = z0_packed_data;    
                        v5.position = voxel_pos_translated + vec3(0.0, 1.0, 0.0) * i;
                        v5.packed_data = z0_packed_data;

                        vertices[local_base_idx] = v0;
                        vertices[local_base_idx + 1] = v1;
                        vertices[local_base_idx + 2] = v2;
                        vertices[local_base_idx + 3] = v3;
                        vertices[local_base_idx + 4] = v4;
                        vertices[local_base_idx + 5] = v5;
                    }

                    atomicOr(processing_buffer_z0[correct_z_mask], 1 << (z_mask_done_bit));

                }

            }

            else{
                // single face at position
                if (col_idx_z0 == 0 && col_idx != 0){
                    uint local_base_idx = atomicAdd(indirect_command.count, 6);

                    uint normal_index = 0;
                    uint z0_packed_data = (col_idx & 255) | (normal_index << 8);

                    Vertex v0, v1, v2, v3, v4, v5;
                    v0.position = voxel_pos_translated;
                    v0.packed_data = z0_packed_data;
                    v1.position = voxel_pos_translated + vec3(1.0, 0.0, 0.0);
                    v1.packed_data = z0_packed_data;
                    v2.position = voxel_pos_translated + vec3(1.0, 1.0, 0.0);
                    v2.packed_data = z0_packed_data;

                    v3.position = voxel_pos_translated;
                    v3.packed_data = z0_packed_data;
                    v4.position = voxel_pos_translated + vec3(1.0, 1.0, 0.0);
                    v4.packed_data = z0_packed_data;    
                    v5.position = voxel_pos_translated + vec3(0.0, 1.0, 0.0);
                    v5.packed_data = z0_packed_data;

                    vertices[local_base_idx] = v0;
                    vertices[local_base_idx + 1] = v1;
                    vertices[local_base_idx + 2] = v2;
                    vertices[local_base_idx + 3] = v3;
                    vertices[local_base_idx + 4] = v4;
                    vertices[local_base_idx + 5] = v5;
                }
            }
        }

        barrier();

        // face z0 end //

         //   face z1  //

        // check if 2x2 group of voxels has been processed yet
        if (!bool((processing_buffer_z1[correct_z_mask] >> (z_mask_done_bit)) & 1)){     // 0 = face not processed yet

            // if not layer 3
            // up to layer 2, single faces are handled differently
            if (i > 1){
                // example 17: 
                // layer 0: i = 3 | (8 / 8) * (2 / 8) + 1 / 8 = 1 * 0 + 0 = 0
                // layer 1: i = 2 | (8 / 4) * (2 / 4) + 1 / 4 = 2 * 0 + 0 = 0
                // layer 2: i = 1 | (8 / 2) * (2 / 2) + 1 / 2 = 4 * 1 + 0 = 4
                // layer 3: i = 0 | (8 / 1) * (2 / 1) + 1 / 1 = 8 * 2 + 1 = 17

                // processing bits from left to right (uint layout): | 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 | done data |

                int correct_processing_bit = (8 / i) * (int(local_pos.y) / i) + (int(local_pos.x) / i);
                
                // check whether face can potentially be processed into bigger face based on neighbouring color indices

                int processing_bit_x0 = -1;
                int processing_bit_x1 = -1;
                int processing_bit_y0 = -1;
                int processing_bit_y1 = -1;

                if(x0_in_area)
                    processing_bit_x0 = (8 / i) * (int(local_pos.y) / i) + (int(local_pos.x - 1.0) / i);
                if(x1_in_area)
                    processing_bit_x1 = (8 / i) * (int(local_pos.y) / i) + (int(local_pos.x + 1.0) / i);
                if(y0_in_area)
                    processing_bit_y0 = (8 / i) * (int(local_pos.y - 1.0) / i) + (int(local_pos.x) / i);
                if(y1_in_area)
                    processing_bit_y1 = (8 / i) * (int(local_pos.y + 1.0) / i) + (int(local_pos.x) / i);


                if (
                    (correct_processing_bit == processing_bit_x0 && col_idx_x0 != col_idx) ||
                    (correct_processing_bit == processing_bit_x1 && col_idx_x1 != col_idx) ||
                    (correct_processing_bit == processing_bit_y0 && col_idx_y0 != col_idx) ||
                    (correct_processing_bit == processing_bit_y1 && col_idx_y1 != col_idx) ||
                    (col_idx_z1 != 0) ||
                    (col_idx == 0)
                )
                {
                    atomicOr(processing_buffer_z1[correct_z_mask], 1 << (16 + correct_processing_bit));
                }

                // wait for all faces to write their bits into the processing mask
                barrier();

                uint processing_bit_state = (processing_buffer_z1[correct_z_mask] >> (16 + correct_processing_bit)) & 1;
                // 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0

                // if processing mask bit is still 0 this face can be created!
                if ((processing_bit_state & 1) == 0)
                {
                    if (int(local_pos.x) % i == 0 && int(local_pos.y) % i == 0){
                        uint local_base_idx = atomicAdd(indirect_command.count, 6);
                        
                        uint normal_index = 3;
                        uint z1_packed_data = (col_idx & 255) | (normal_index << 8);

                        Vertex v0, v1, v2, v3, v4, v5;
                        v0.position = voxel_pos_translated + vec3(0.0, 0.0, 1.0);
                        v0.packed_data = z1_packed_data;
                        v1.position = voxel_pos_translated + vec3(1.0, 1.0, 0.0) * i + vec3(0.0, 0.0, 1.0);
                        v1.packed_data = z1_packed_data;
                        v2.position = voxel_pos_translated + vec3(1.0, 0.0, 0.0) * i + vec3(0.0, 0.0, 1.0);
                        v2.packed_data = z1_packed_data;

                        v3.position = voxel_pos_translated + vec3(1.0, 1.0, 0.0) * i + vec3(0.0, 0.0, 1.0);
                        v3.packed_data = z1_packed_data;
                        v4.position = voxel_pos_translated + vec3(0.0, 0.0, 1.0);
                        v4.packed_data = z1_packed_data;    
                        v5.position = voxel_pos_translated + vec3(0.0, 1.0, 0.0) * i + vec3(0.0, 0.0, 1.0);
                        v5.packed_data = z1_packed_data;

                        vertices[local_base_idx] = v0;
                        vertices[local_base_idx + 1] = v1;
                        vertices[local_base_idx + 2] = v2;
                        vertices[local_base_idx + 3] = v3;
                        vertices[local_base_idx + 4] = v4;
                        vertices[local_base_idx + 5] = v5;
                    }

                    atomicOr(processing_buffer_z1[correct_z_mask], 1 << (z_mask_done_bit));

                }

            }

            else{
                // single face at position
                if (col_idx_z1 == 0 && col_idx != 0){
                    uint local_base_idx = atomicAdd(indirect_command.count, 6);

                    uint normal_index = 3;
                    uint z1_packed_data = (col_idx & 255) | (normal_index << 8);

                    Vertex v0, v1, v2, v3, v4, v5;
                    v0.position = voxel_pos_translated + vec3(0.0, 0.0, 1.0);
                    v0.packed_data = z1_packed_data;
                    v1.position = voxel_pos_translated + vec3(1.0, 1.0, 1.0);
                    v1.packed_data = z1_packed_data;
                    v2.position = voxel_pos_translated + vec3(1.0, 0.0, 1.0);
                    v2.packed_data = z1_packed_data;

                    v3.position = voxel_pos_translated + vec3(1.0, 1.0, 1.0);
                    v3.packed_data = z1_packed_data;
                    v4.position = voxel_pos_translated + vec3(0.0, 0.0, 1.0);
                    v4.packed_data = z1_packed_data;    
                    v5.position = voxel_pos_translated + vec3(0.0, 1.0, 1.0);
                    v5.packed_data = z1_packed_data;

                    vertices[local_base_idx] = v0;
                    vertices[local_base_idx + 1] = v1;
                    vertices[local_base_idx + 2] = v2;
                    vertices[local_base_idx + 3] = v3;
                    vertices[local_base_idx + 4] = v4;
                    vertices[local_base_idx + 5] = v5;
                }
            }
        }

        barrier();

        // face z1 end //

        //   face y0  //
        // check if 2x2 group of voxels has been processed yet
        if (!bool((processing_buffer_y0[correct_y_mask] >> (y_mask_done_bit)) & 1)){     // 0 = face not processed yet

            // if not layer 3
            // up to layer 2, single faces are handled differently
            if (i > 1){
                // example 17: 
                // layer 0: i = 3 | (8 / 8) * (2 / 8) + 1 / 8 = 1 * 0 + 0 = 0
                // layer 1: i = 2 | (8 / 4) * (2 / 4) + 1 / 4 = 2 * 0 + 0 = 0
                // layer 2: i = 1 | (8 / 2) * (2 / 2) + 1 / 2 = 4 * 1 + 0 = 4
                // layer 3: i = 0 | (8 / 1) * (2 / 1) + 1 / 1 = 8 * 2 + 1 = 17

                // processing bits from left to right (uint layout): | 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 | done data |

                int correct_processing_bit = (8 / i) * (int(local_pos.z) / i) + (int(local_pos.x) / i);
                
                // check whether face can potentially be processed into bigger face based on neighbouring color indices

                int processing_bit_x0 = -1;
                int processing_bit_x1 = -1;
                int processing_bit_z0 = -1;
                int processing_bit_z1 = -1;

                if(x0_in_area)
                    processing_bit_x0 = (8 / i) * (int(local_pos.z) / i) + (int(local_pos.x - 1.0) / i);
                if(x1_in_area)
                    processing_bit_x1 = (8 / i) * (int(local_pos.z) / i) + (int(local_pos.x + 1.0) / i);
                if(z0_in_area)
                    processing_bit_z0 = (8 / i) * (int(local_pos.z - 1.0) / i) + (int(local_pos.x) / i);
                if(z1_in_area)
                    processing_bit_z1 = (8 / i) * (int(local_pos.z + 1.0) / i) + (int(local_pos.x) / i);

                if (
                    (correct_processing_bit == processing_bit_x0 && col_idx_x0 != col_idx) ||
                    (correct_processing_bit == processing_bit_x1 && col_idx_x1 != col_idx) ||
                    (correct_processing_bit == processing_bit_z0 && col_idx_z0 != col_idx) ||
                    (correct_processing_bit == processing_bit_z1 && col_idx_z1 != col_idx) ||
                    (col_idx_y0 != 0) ||
                    (col_idx == 0)
                )
                {
                    atomicOr(processing_buffer_y0[correct_y_mask], 1 << (16 + correct_processing_bit));
                }

                // wait for all faces to write their bits into the processing mask
                barrier();

                uint processing_bit_state = (processing_buffer_y0[correct_y_mask] >> (16 + correct_processing_bit)) & 1;
                // 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0

                // if processing mask bit is still 0 this face can be created!
                if ((processing_bit_state & 1) == 0)
                {
                    if (int(local_pos.x) % i == 0 && int(local_pos.z) % i == 0){
                        uint local_base_idx = atomicAdd(indirect_command.count, 6);
                        
                        uint normal_index = 4;
                        uint y0_packed_data = (col_idx & 255) | (normal_index << 8);

                        Vertex v0, v1, v2, v3, v4, v5;
                        v0.position = voxel_pos_translated;
                        v0.packed_data = y0_packed_data;
                        v1.position = voxel_pos_translated + vec3(1.0, 0.0, 1.0) * i;
                        v1.packed_data = y0_packed_data;
                        v2.position = voxel_pos_translated + vec3(1.0, 0.0, 0.0) * i;
                        v2.packed_data = y0_packed_data;

                        v3.position = voxel_pos_translated + vec3(1.0, 0.0, 1.0) * i;
                        v3.packed_data = y0_packed_data;
                        v4.position = voxel_pos_translated;
                        v4.packed_data = y0_packed_data;    
                        v5.position = voxel_pos_translated + vec3(0.0, 0.0, 1.0) * i;
                        v5.packed_data = y0_packed_data;

                        vertices[local_base_idx] = v0;
                        vertices[local_base_idx + 1] = v1;
                        vertices[local_base_idx + 2] = v2;
                        vertices[local_base_idx + 3] = v3;
                        vertices[local_base_idx + 4] = v4;
                        vertices[local_base_idx + 5] = v5;
                    }

                    atomicOr(processing_buffer_y0[correct_y_mask], 1 << (y_mask_done_bit));

                }

            }

            else{
                // single face at position
                if (col_idx_y0 == 0 && col_idx != 0){
                    uint local_base_idx = atomicAdd(indirect_command.count, 6);

                    uint normal_index = 4;
                    uint y0_packed_data = (col_idx & 255) | (normal_index << 8);

                    Vertex v0, v1, v2, v3, v4, v5;
                    v0.position = voxel_pos_translated + vec3(0.0, 0.0, 0.0);
                    v0.packed_data = y0_packed_data;
                    v1.position = voxel_pos_translated + vec3(1.0, 0.0, 1.0);
                    v1.packed_data = y0_packed_data;
                    v2.position = voxel_pos_translated + vec3(1.0, 0.0, 0.0);
                    v2.packed_data = y0_packed_data;

                    v3.position = voxel_pos_translated + vec3(1.0, 0.0, 1.0);
                    v3.packed_data = y0_packed_data;
                    v4.position = voxel_pos_translated + vec3(0.0, 0.0, 0.0);
                    v4.packed_data = y0_packed_data;
                    v5.position = voxel_pos_translated + vec3(0.0, 0.0, 1.0);
                    v5.packed_data = y0_packed_data;

                    vertices[local_base_idx] = v0;
                    vertices[local_base_idx + 1] = v1;
                    vertices[local_base_idx + 2] = v2;
                    vertices[local_base_idx + 3] = v3;
                    vertices[local_base_idx + 4] = v4;
                    vertices[local_base_idx + 5] = v5;
                }
            }
        }

        barrier();

        // face y0 end //

        //   face y1  //
        // check if 2x2 group of voxels has been processed yet
        if (!bool((processing_buffer_y1[correct_y_mask] >> (y_mask_done_bit)) & 1)){     // 0 = face not processed yet

            // if not layer 3
            // up to layer 2, single faces are handled differently
            if (i > 1){
                // example 17: 
                // layer 0: i = 3 | (8 / 8) * (2 / 8) + 1 / 8 = 1 * 0 + 0 = 0
                // layer 1: i = 2 | (8 / 4) * (2 / 4) + 1 / 4 = 2 * 0 + 0 = 0
                // layer 2: i = 1 | (8 / 2) * (2 / 2) + 1 / 2 = 4 * 1 + 0 = 4
                // layer 3: i = 0 | (8 / 1) * (2 / 1) + 1 / 1 = 8 * 2 + 1 = 17

                // processing bits from left to right (uint layout): | 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 | done data |

                int correct_processing_bit = (8 / i) * (int(local_pos.z) / i) + (int(local_pos.x) / i);
                
                // check whether face can potentially be processed into bigger face based on neighbouring color indices

                int processing_bit_x0 = -1;
                int processing_bit_x1 = -1;
                int processing_bit_z0 = -1;
                int processing_bit_z1 = -1;

                if(x0_in_area)
                    processing_bit_x0 = (8 / i) * (int(local_pos.z) / i) + (int(local_pos.x - 1.0) / i);
                if(x1_in_area)
                    processing_bit_x1 = (8 / i) * (int(local_pos.z) / i) + (int(local_pos.x + 1.0) / i);
                if(z0_in_area)
                    processing_bit_z0 = (8 / i) * (int(local_pos.z - 1.0) / i) + (int(local_pos.x) / i);
                if(z1_in_area)
                    processing_bit_z1 = (8 / i) * (int(local_pos.z + 1.0) / i) + (int(local_pos.x) / i);

                if (
                    (correct_processing_bit == processing_bit_x0 && col_idx_x0 != col_idx) ||
                    (correct_processing_bit == processing_bit_x1 && col_idx_x1 != col_idx) ||
                    (correct_processing_bit == processing_bit_z0 && col_idx_z0 != col_idx) ||
                    (correct_processing_bit == processing_bit_z1 && col_idx_z1 != col_idx) ||
                    (col_idx_y1 != 0) ||
                    (col_idx == 0)
                )
                {
                    atomicOr(processing_buffer_y1[correct_y_mask], 1 << (16 + correct_processing_bit));
                }

                // wait for all faces to write their bits into the processing mask
                barrier();

                uint processing_bit_state = (processing_buffer_y1[correct_y_mask] >> (16 + correct_processing_bit)) & 1;
                // 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0

                // if processing mask bit is still 0 this face can be created!
                if ((processing_bit_state & 1) == 0)
                {
                    if (int(local_pos.x) % i == 0 && int(local_pos.z) % i == 0){
                        uint local_base_idx = atomicAdd(indirect_command.count, 6);
                        
                        uint normal_index = 5;
                        uint y1_packed_data = (col_idx & 255) | (normal_index << 8);

                        Vertex v0, v1, v2, v3, v4, v5;
                        v0.position = voxel_pos_translated + vec3(0.0, 1.0, 0.0);
                        v0.packed_data = y1_packed_data;
                        v1.position = voxel_pos_translated + vec3(1.0, 0.0, 0.0) * i + vec3(0.0, 1.0, 0.0);
                        v1.packed_data = y1_packed_data;
                        v2.position = voxel_pos_translated + vec3(1.0, 0.0, 1.0) * i + vec3(0.0, 1.0, 0.0);
                        v2.packed_data = y1_packed_data;

                        v3.position = voxel_pos_translated + vec3(1.0, 0.0, 1.0) * i + vec3(0.0, 1.0, 0.0);
                        v3.packed_data = y1_packed_data;
                        v4.position = voxel_pos_translated + vec3(0.0, 0.0, 1.0) * i + vec3(0.0, 1.0, 0.0);
                        v4.packed_data = y1_packed_data;    
                        v5.position = voxel_pos_translated + vec3(0.0, 1.0, 0.0);
                        v5.packed_data = y1_packed_data;

                        vertices[local_base_idx] = v0;
                        vertices[local_base_idx + 1] = v1;
                        vertices[local_base_idx + 2] = v2;
                        vertices[local_base_idx + 3] = v3;
                        vertices[local_base_idx + 4] = v4;
                        vertices[local_base_idx + 5] = v5;
                    }

                    atomicOr(processing_buffer_y1[correct_y_mask], 1 << (y_mask_done_bit));

                }

            }

            else{
                // single face at position
                if (col_idx_y1 == 0 && col_idx != 0){

                    uint local_base_idx = atomicAdd(indirect_command.count, 6);

                    uint normal_index = 5;
                    uint y1_packed_data = (col_idx & 255) | (normal_index << 8);

                    Vertex v0, v1, v2, v3, v4, v5;
                    v0.position = voxel_pos_translated + vec3(0.0, 1.0, 0.0);
                    v0.packed_data = y1_packed_data;
                    v1.position = voxel_pos_translated + vec3(1.0, 1.0, 0.0);
                    v1.packed_data = y1_packed_data;
                    v2.position = voxel_pos_translated + vec3(1.0, 1.0, 1.0);
                    v2.packed_data = y1_packed_data;

                    v3.position = voxel_pos_translated + vec3(1.0, 1.0, 1.0);
                    v3.packed_data = y1_packed_data;
                    v4.position = voxel_pos_translated + vec3(0.0, 1.0, 1.0);
                    v4.packed_data = y1_packed_data;
                    v5.position = voxel_pos_translated + vec3(0.0, 1.0, 0.0);
                    v5.packed_data = y1_packed_data;

                    vertices[local_base_idx] = v0;
                    vertices[local_base_idx + 1] = v1;
                    vertices[local_base_idx + 2] = v2;
                    vertices[local_base_idx + 3] = v3;
                    vertices[local_base_idx + 4] = v4;
                    vertices[local_base_idx + 5] = v5;
                }
            }
        }


        barrier();

        // face y1 end //

    }
}